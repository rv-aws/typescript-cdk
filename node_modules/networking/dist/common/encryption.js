"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_forge_1 = __importDefault(require("node-forge"));
const sha_js_1 = __importDefault(require("sha.js"));
const crypto_1 = __importDefault(require("crypto"));
class Encryption {
    /**
     * Encrypts data with the given key, and returns the ciphered bytes as a buffer. The first 16 bytes in the buffer
     * will always be the initialization vector used during encryption. The data is padded automatically with PKCS#7.
     *
     * @param key Must equal 256 bits
     * @param data
     */
    static encrypt(key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            let iv = yield this.generateIV();
            let cipher = node_forge_1.default.cipher.createCipher('AES-CBC', node_forge_1.default.util.createBuffer(key));
            cipher.start({ iv: node_forge_1.default.util.createBuffer(iv) });
            cipher.update(node_forge_1.default.util.createBuffer(data));
            cipher.finish();
            return Buffer.concat([
                iv,
                Buffer.from(cipher.output.getBytes(), 'binary')
            ]);
        });
    }
    /**
     * Decrypts data with the given key, and returns the original data as a buffer. The first 16 bytes in the ciphered
     * data must be the initialization vector that was used to encrypt the message. The data is padded automatically
     * with PKCS#7.
     *
     * @param key Must equal 256 bits
     * @param data
     */
    static decrypt(key, data) {
        return __awaiter(this, void 0, void 0, function* () {
            let iv = node_forge_1.default.util.createBuffer(data.slice(0, 16));
            let cipherText = node_forge_1.default.util.createBuffer(data.slice(16));
            let decipher = node_forge_1.default.cipher.createDecipher('AES-CBC', node_forge_1.default.util.createBuffer(key));
            decipher.start({ iv });
            decipher.update(cipherText);
            if (!decipher.finish()) {
                throw new Error('Decrypt failed');
            }
            return Buffer.from(decipher.output.getBytes(), 'binary');
        });
    }
    /**
     * Asynchronously generates a secure, random initialization vector for encryption.
     */
    static generateIV() {
        return new Promise((resolve, reject) => {
            crypto_1.default.randomBytes(16, (err, buf) => {
                if (err)
                    return reject(err);
                resolve(buf);
            });
        });
    }
    /**
     * Asynchronously generates a secure, random string of the specified number of bytes.
     */
    static generateRandom(bytes) {
        return new Promise((resolve, reject) => {
            crypto_1.default.randomBytes(bytes, (err, buf) => {
                if (err)
                    return reject(err);
                resolve(buf);
            });
        });
    }
    /**
     * Generates a 256-bit key from a password of any serializable type and size.
     *
     * @param password
     */
    static generateKey(password) {
        return sha_js_1.default('sha256').update(JSON.stringify(password)).digest('latin1');
    }
}
exports.Encryption = Encryption;
