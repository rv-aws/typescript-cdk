"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const receipt_1 = require("./receipt");
const request_1 = require("./request");
const object_hash_1 = __importDefault(require("object-hash"));
class SubscriptionEmitter {
    constructor(client) {
        this.client = client;
        /**
         * The next ID to use for a local subscription.
         * @internal
         */
        this.nextSubscriptionId = 0;
        /**
         * Local subscriptions, for which we have requested the remote to send us new values.
         * @internal
         */
        this.local = {};
        /**
         * Remote subscriptions, for which the remote has requested us to send new values.
         * @internal
         */
        this.remote = {};
        /**
         * Local functions for guarding incoming subscriptions.
         * @internal
         */
        this.guards = {};
    }
    /**
     * The current socket for the client. Throws an error if a socket is not available.
     * @internal
     */
    get socket() {
        let socket = this.client.getSocket();
        if (socket)
            return socket;
        throw new Error('Cannot emit while disconnected');
    }
    emit(event, filter, value) {
        if (this.hasRemoteSubscriptions(event, filter)) {
            this.socket.emit('@net/subscription/emit', event, filter, value);
        }
    }
    on(event, handler) {
        if (!(event in this.guards))
            this.guards[event] = [];
        this.guards[event].push(handler);
    }
    create(event, filter, handler) {
        return new Promise((resolve, reject) => {
            let id = this.nextSubscriptionId++;
            let filterHash = object_hash_1.default(filter);
            let receipt = new receipt_1.Receipt(this, event, filterHash, id);
            // Create the store objects as needed
            if (!(event in this.local))
                this.local[event] = {};
            if (!(filterHash in this.local[event]))
                this.local[event][filterHash] = [];
            // Add the subscription
            this.local[event][filterHash].push({ id, handler, receipt });
            // Notify the remote
            this.socket.emit('@net/subscription/create', id, event, filter, (success) => {
                // Upon success, resolve with the receipt
                if (success) {
                    resolve(receipt);
                }
                // If the add wasn't successful on the remote, remove it and reject
                else {
                    this.local[event][filterHash] = this.local[event][filterHash].filter(sub => sub.id !== id);
                    reject(new Error('Subscription was rejected by the remote'));
                }
            });
        });
    }
    remove(event, filter, handlerOrId) {
        let filterHash = (typeof handlerOrId === 'number') ? filter : object_hash_1.default(filter);
        if (event in this.local) {
            if (filterHash in this.local[event]) {
                let closed = [];
                this.local[event][filterHash] = this.local[event][filterHash].filter(sub => {
                    let matchesId = (typeof handlerOrId === 'number' && sub.id === handlerOrId);
                    let matchesHandler = (typeof handlerOrId === 'function' && sub.handler === handlerOrId);
                    if (matchesId || matchesHandler) {
                        closed.push(sub.id);
                        return false;
                    }
                    return true;
                });
                if (closed.length) {
                    this.socket.emit('@net/subscription/close', event, filterHash, closed);
                }
            }
        }
    }
    /**
     * Closes all of our active subscriptions. This only applies to local subscriptions which received new values from
     * the remote. All subscriptions originating from the remote will persist until closed from the remote's end.
     */
    clear() {
        this.local = {};
        this.socket.emit('@net/subscription/clear');
    }
    /**
     * Returns `true` if there are remote subscriptions for the given event and filter.
     *
     * @param event
     * @param filter
     * @internal
     */
    hasRemoteSubscriptions(event, filter) {
        if (event in this.remote) {
            let filterHash = object_hash_1.default(filter);
            if (filterHash in this.remote[event]) {
                return this.remote[event][filterHash].length > 0;
            }
        }
        return false;
    }
    /**
     * Returns an array of guards for the given event.
     *
     * @param event
     * @internal
     */
    getGuards(event) {
        if (event in this.guards) {
            return this.guards[event];
        }
        return [];
    }
    /**
     * Checks all guards against the given subscription details and returns `true` if the subscription request is
     * authorized and can be honored.
     *
     * @param event
     * @param id
     * @param filter
     * @internal
     */
    canCreateSubscription(event, id, filter) {
        return __awaiter(this, void 0, void 0, function* () {
            let guards = this.getGuards(event);
            let request = new request_1.Request(id, filter);
            for (let guard of guards) {
                let response = guard(request);
                // Wait for promises to resolve
                if (response instanceof Promise)
                    yield response;
                // If rejected, return false immediately
                if (request.rejected)
                    return false;
            }
            return true;
        });
    }
    /**
     * Handles an incoming subscription from the remote.
     * @internal
     */
    onSubscription(id, event, filter, ack) {
        return __awaiter(this, void 0, void 0, function* () {
            let filterHash = object_hash_1.default(filter);
            // Create the store objects as needed
            if (!(event in this.remote))
                this.remote[event] = {};
            if (!(filterHash in this.remote[event]))
                this.remote[event][filterHash] = [];
            // Check for guards and make sure the subscription is permitted
            if (yield this.canCreateSubscription(event, id, filter)) {
                this.remote[event][filterHash].push(id);
                ack(true);
            }
            else {
                ack(false);
            }
        });
    }
    /**
     * Handles an incoming subscription value update from the remote.
     *
     * @param event
     * @param filter
     * @param value
     * @internal
     */
    onSubscriptionValue(event, filter, value) {
        let filterHash = object_hash_1.default(filter);
        if (event in this.local) {
            if (filterHash in this.local[event]) {
                let subscriptions = this.local[event][filterHash];
                for (let subscription of subscriptions) {
                    subscription.handler(subscription.receipt, value);
                }
            }
        }
    }
    /**
     * Handles a request from the remote to close one of its subscriptions.
     *
     * @param event
     * @param hash
     * @param id
     * @internal
     */
    onSubscriptionClose(event, filterHash, ids) {
        if (event in this.remote) {
            if (filterHash in this.remote[event]) {
                this.remote[event][filterHash] = this.remote[event][filterHash].filter(id => ids.indexOf(id) < 0);
            }
        }
    }
    /**
     * Handles a clear request from the remote to close all of its subscriptions.
     */
    onSubscriptionClear() {
        this.remote = {};
    }
}
exports.SubscriptionEmitter = SubscriptionEmitter;
