import { Json } from '../serialize';
/**
 * The schematic defines all events and types sent over the library.
 */
export interface Schematic {
    /**
     * Defines types for authentication.
     */
    authentication?: {
        login?: Json;
        encrypt?: Json;
    };
    /**
     * Defines what events the client can send to the server.
     */
    client?: Group;
    /**
     * Defines what events the server can send to the client.
     */
    server?: Group;
}
export interface Group {
    /**
     * Defines all transactions (one-way events) that the server can receive from the client.
     */
    transactions?: {
        [name: string]: (...args: any[]) => void;
    };
    /**
     * Defines all requests (fetch events) that the server can receive from the client, as well as the return
     * types that will be sent back to the client.
     */
    requests?: {
        [name: string]: (...args: any[]) => any;
    };
    /**
     * Defines all streams (chunked binary events) that the server can receive from the client. Do not include
     * the stream parameter in your declarations.
     */
    streams?: {
        [name: string]: (...args: any[]) => any;
    };
    /**
     * Defines all subscription events that the server can emit to the client, if the client has subscribed to
     * those events.
     */
    subscriptions?: {
        [name: string]: {
            filter: Json;
            value: Json;
        };
    };
}
export declare type Subscription<Filter extends Json, Value extends Json> = {
    filter: Filter;
    value: Value;
};
export declare type Pull<T, K extends keyof NonNullable<T>, F = any> = T extends undefined ? F : (NonNullable<T>[K] extends undefined ? F : NonNullable<T>[K]);
export declare type Key<T, F = string> = T extends undefined ? F : Extract<keyof NonNullable<T>, string>;
export declare type Value<G, K extends Key<G>, F = never> = G extends undefined ? F : NonNullable<G>[Exclude<K, string>];
export declare type Fallback<T, F = string> = T extends undefined ? F : NonNullable<T>;
