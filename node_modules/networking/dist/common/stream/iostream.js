"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
class IOStream extends stream_1.Duplex {
    constructor(options = {}, id = '', streamer) {
        super(options);
        this.options = options;
        this.id = id;
        this.streamer = streamer;
        /**
         * @internal
         */
        this.pushBuffer = [];
        /**
         * @internal
         */
        this.writeBuffer = [];
        /**
         * @internal
         */
        this._readable = false;
        /**
         * @internal
         */
        this._writable = false;
        /**
         * @internal
         */
        this.destroyed = false;
        /**
         * @internal
         */
        this.rejected = false;
        /**
         * @internal
         */
        this.streaming = true;
        /**
         * @internal
         */
        this.streamingQueue = [];
        /**
         * The number of milliseconds to wait before sending data, useful for sending data at a slower rate or throttling.
         * Defaults to `0`, which means no delay.
         */
        this.delay = 0;
        this.on('finish', this._onFinish);
        this.on('end', this._onEnd);
        this.on('error', this._onError);
    }
    /**
     * @internal
     */
    destroy() {
        if (this.destroyed)
            return;
        if (this.streamer) {
            this.streamer.cleanup(this.id);
            this.streamer = undefined;
        }
        this.destroyed = true;
        this.readable = this.writable = false;
    }
    /**
     * Rejects the stream. Only applicable on the recipient machine.
     *
     * @param message Optional error message to send to the sender
     */
    reject(message) {
        this.rejected = true;
        this.rejectionReason = message;
        this.emit('reject', message);
    }
    /**
     * Local read.
     *
     * @param size
     * @internal
     */
    _read(size) {
        if (this.destroyed)
            return;
        if (!this.streaming) {
            this.streamingQueue.push(size);
            return;
        }
        let push;
        if (this.pushBuffer.length) {
            while (push = this.pushBuffer.shift()) {
                if (!push())
                    break;
            }
            return;
        }
        this._readable = true;
        this.streamer.read(this.id, size);
    }
    /**
     * Reads from the remote stream.
     *
     * @param size
     * @internal
     */
    _onRead(size) {
        let write = this.writeBuffer.shift();
        if (write)
            return write();
        this._writable = true;
    }
    /**
     * Write local data to the remote stream.
     *
     * @param chunk
     * @param encoding
     * @param callback
     * @internal
     */
    _write(chunk, encoding, callback) {
        let write = (() => {
            if (this.destroyed)
                return;
            this._writable = false;
            this.streamer.write(this.id, chunk, encoding, callback);
            this.emit('data', chunk);
        });
        let exec = (() => {
            if (this._writable)
                write();
            else
                this.writeBuffer.push(write);
        });
        if (this.delay === 0)
            exec();
        else
            setTimeout(exec, this.delay);
    }
    /**
     * Pipe remote data into the local stream.
     *
     * @param chunk
     * @param encoding
     * @param callback
     * @internal
     */
    _onWrite(chunk, encoding, callback) {
        let push = (() => {
            this._readable = false;
            let ret = this.push(chunk || '', encoding);
            callback();
            return ret;
        });
        if (this._readable)
            push();
        else
            this.pushBuffer.push(push);
    }
    /**
     * End the stream, and notify the remote.
     * @internal
     */
    _end() {
        if (this.pushBuffer.length) {
            this.pushBuffer.push(() => this._done());
        }
        else {
            this._done();
        }
    }
    /**
     * Finish the stream.
     * @internal
     */
    _done() {
        this._readable = false;
        this.push(null);
    }
    /**
     * The stream is finished, and all data has been sent to the remote. Clean up the stream from the streamer
     * instance and disable read/write access.
     * @internal
     */
    _onFinish() {
        if (this.streamer) {
            this.streamer.end(this.id);
        }
        this.writable = false;
        this._writableState.ended = true;
        if (!this.readable || this._readableState.ended) {
            return this.destroy();
        }
        this.push(null);
        if (this.readable && !this._readableState.endEmitted) {
            this.read(0);
        }
    }
    /**
     * The stream has ended (eof), now notify the remote and clean up.
     * @internal
     */
    _onEnd() {
        this.readable = false;
        this._readableState.ended = true;
        if (!this.writable || this._writableState.finished) {
            return this.destroy();
        }
        this.end();
    }
    /**
     * Notify the remote of an error and terminate the stream.
     *
     * @param err
     * @internal
     */
    _onError(err) {
        if (!err.remote && this.streamer) {
            this.streamer.error(this.id, err);
        }
        this.destroy();
    }
}
exports.IOStream = IOStream;
