"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const iostream_1 = require("./iostream");
const errors_1 = require("../errors");
const client_1 = require("../../client/client");
const v4_1 = __importDefault(require("uuid/v4"));
class Streamer {
    constructor(client, socket) {
        this.client = client;
        this.socket = socket;
        this.streams = {};
        socket.on('@net/stream/read', this.onRead.bind(this));
        socket.on('@net/stream/write', this.onWrite.bind(this));
        socket.on('@net/stream/end', this.onEnd.bind(this));
        socket.on('@net/stream/error', this.onError.bind(this));
        socket.on('disconnect', this.onSocketDisconnect.bind(this));
    }
    generateId() {
        let bit = (this.client instanceof client_1.Client) ? "0" : "1";
        let id = bit + v4_1.default();
        // Most definitely not needed, but just in case...
        while (id in this.streams)
            id = bit + v4_1.default();
        return id;
    }
    createStream(options = {}) {
        let id = this.generateId();
        let stream = new iostream_1.IOStream(options, id, this);
        this.streams[id] = stream;
        return stream;
    }
    convertStream(stream, id) {
        let io;
        // If the stream is already an IOStream, update the id
        if (stream instanceof iostream_1.IOStream) {
            stream.id = id;
            io = stream;
        }
        // Otherwise, we need to make an IOStream and pipe it
        else {
            io = new iostream_1.IOStream({}, id, this);
            stream.pipe(io);
        }
        return io;
    }
    sendStream(id, stream, tracker) {
        if (id in this.streams) {
            throw new Error(`Got duplicate stream id ${id} from remote`);
        }
        // Add the stream
        this.streams[id] = stream;
        // Tell the remote to start sending data
        this.socket.emit('@net/stream/' + id);
    }
    onRead(id, size) {
        let stream = this.streams[id];
        if (stream) {
            stream._onRead(size);
        }
    }
    onWrite(id, chunk, encoding, callback) {
        let stream = this.streams[id];
        if (stream) {
            if (chunk instanceof ArrayBuffer) {
                chunk = Buffer.from(chunk);
            }
            stream._onWrite(chunk, encoding, callback);
        }
    }
    onEnd(id) {
        let stream = this.streams[id];
        if (stream) {
            stream._end();
        }
    }
    onError(id, message) {
        let stream = this.streams[id];
        if (stream) {
            let error = new errors_1.StreamError(message, true);
            stream.emit('error', error);
        }
    }
    onSocketDisconnect() {
        for (let id in this.streams) {
            let stream = this.streams[id];
            stream.destroy();
            stream.emit('close');
            stream.emit('error', new Error('Disconnected'));
        }
    }
    read(id, size) {
        this.socket.emit('@net/stream/read', id, size);
    }
    write(id, chunk, encoding, callback) {
        if (Buffer.isBuffer(chunk)) {
            encoding = 'base64';
            chunk = chunk.toString(encoding);
        }
        this.socket.emit('@net/stream/write', id, chunk, encoding, callback);
    }
    end(id) {
        this.socket.emit('@net/stream/end', id);
    }
    error(id, error) {
        this.socket.emit('@net/stream/error', id, error.message || error);
    }
    cleanup(id) {
        if (id in this.streams) {
            this.streams[id].emit('close');
        }
        delete this.streams[id];
    }
}
exports.Streamer = Streamer;
;
