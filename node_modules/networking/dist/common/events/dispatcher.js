"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const iostream_1 = require("../stream/iostream");
const errors_1 = require("../errors");
class Dispatcher {
    constructor(client, socket, emitters) {
        this.client = client;
        this.socket = socket;
        this.emitters = emitters;
        let subs = emitters.subscriptions;
        // Dispatch transactions, requests, and streams
        socket.on('@net/transaction', this.onTransaction.bind(this));
        socket.on('@net/request', this.onRequest.bind(this));
        socket.on('@net/stream', this.onStream.bind(this));
        // Dispatch subscriptions
        socket.on('@net/subscription/create', subs.onSubscription.bind(subs));
        socket.on('@net/subscription/emit', subs.onSubscriptionValue.bind(subs));
        socket.on('@net/subscription/close', subs.onSubscriptionClose.bind(subs));
        socket.on('@net/subscription/clear', subs.onSubscriptionClear.bind(subs));
    }
    createStream(options) {
        return new iostream_1.IOStream(options || {});
    }
    onTransaction(event, ...args) {
        this.emitters.transactions.listeners(event, true).forEach(listener => {
            listener(...args);
        });
    }
    onRequest(event, ...args) {
        let ack = args.pop();
        let listener = this.emitters.requests.getLastListener(event, true);
        if (ack && typeof ack === 'function' && listener) {
            try {
                let returned = listener(...args);
                if (returned instanceof Promise) {
                    returned.then((res) => ack(true, res), (err) => {
                        throw err;
                    });
                }
                else {
                    ack(true, returned);
                }
            }
            catch (err) {
                if (err instanceof errors_1.StreamError)
                    return ack(err.message);
                ack(false);
                throw err;
            }
        }
        else if (ack && typeof ack === 'function') {
            ack(true, null);
        }
    }
    onStream(event, options, ...args) {
        let ack = args.pop();
        let stream = this.client.getStreamer().createStream(options);
        let listener = this.emitters.streams.getLastListener(event, true);
        // Pause the stream until we are ready to begin sending data
        stream.streaming = false;
        if (listener) {
            try {
                let returned = listener(stream, ...args);
                // Function to start the stream
                let start = (value) => {
                    // Handle rejections
                    if (stream.rejected) {
                        if (stream.rejectionReason)
                            return ack(stream.rejectionReason);
                        return ack(false, null, null);
                    }
                    // Send acknowledgement
                    ack(false, stream.id, value);
                    // Wait for the start signal
                    this.socket.once('@net/stream/' + stream.id, () => {
                        // We're ready to send data
                        stream.streaming = true;
                        stream.streamingQueue.forEach(size => {
                            stream._read(size);
                        });
                    });
                };
                // Check if the function returned a promise, so we can wait for it to resolve
                if (returned instanceof Promise) {
                    return returned.then(value => start(value), error => { throw error; });
                }
                // It's not a promise, so start immediately
                start(returned);
            }
            catch (error) {
                if (error instanceof errors_1.StreamError)
                    return ack(error.message);
                ack(true);
                throw error;
            }
        }
    }
}
exports.Dispatcher = Dispatcher;
;
