"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const emitter_1 = require("./emitter");
const tracker_1 = require("../stream/tracker");
const errors_1 = require("../errors");
class StreamEmitter extends emitter_1.Emitter {
    // public emit(event: string, stream: Stream, ...args: Json[]) : Promise<Tracker>;
    emit(event, stream, ...args) {
        return new Promise((resolve, reject) => {
            let options = stream.options || {};
            this.socket.emit('@net/stream', event, options, ...args, (error, id, value) => {
                if (error) {
                    // The error can be a string with an intentional error, or true for a general error
                    return reject(new errors_1.StreamError((typeof error === 'string') ? error : 'The remote\'s stream handler encountered an error', true));
                }
                if (!id) {
                    // A missing id means the remote rejected the stream without an error message
                    return reject(new errors_1.StreamError('Stream rejected by remote'));
                }
                let iostream = this.client.getStreamer().convertStream(stream, id);
                let tracker = new tracker_1.Tracker(id, value, iostream);
                this.client.getStreamer().sendStream(id, iostream, tracker);
                resolve(tracker);
            });
        });
    }
    // public on(event: string, callback: (stream: IOStream, ...args: Json[]) => void): void;
    on(event, callback) {
        if (!(event in this.callbacks))
            this.callbacks[event] = [];
        this.callbacks[event].push({ once: false, callback });
    }
    // public once(event: string, callback: (stream: IOStream, ...args: Json[]) => void): void;
    once(event, callback) {
        if (!(event in this.callbacks))
            this.callbacks[event] = [];
        this.callbacks[event].push({ once: true, callback });
    }
}
exports.StreamEmitter = StreamEmitter;
