/// <reference types="socket.io-client" />
/// <reference types="node" />
import { Auth } from './auth';
import { EventEmitter } from 'events';
import { RequestEmitter } from '../common/events/requests';
import { StreamEmitter } from '../common/events/streams';
import { TransactionEmitter, Events as TransactionEvents, Callback, Params } from '../common/events/transactions';
import { SubscriptionEmitter, Events as SubscriptionEvents, Filter, Value } from '../common/subscriptions/emitter';
import { Receipt } from '../common/subscriptions/receipt';
import { Schematic, Fallback, Group } from '../common/schema/schematic';
export declare class Client<T extends Schematic = Schematic, I = Fallback<T['client'], Group>, O = Fallback<T['server'], Group>> extends EventEmitter {
    private options;
    /**
     * Constructs a new `Client` instance.
     *
     * @param options
     */
    constructor(options: ClientOptions<T>);
    constructor(host: string, port: number);
    /**
     * Starts the client. If the `auth` parameter is provided, it will be called as an authentication helper and
     * provided an `Auth` instance as the sole parameter. The `auth` callback should generally return a Promise that
     * resolves when all authentication steps are complete.
     *
     * @param auth
     */
    start(auth?: (auth: Auth<T>) => Promise<void> | void): Promise<void>;
    /**
     * Helper for sending transaction events.
     */
    get transaction(): TransactionEmitter<T, I, O>;
    /**
     * Helper for sending request events.
     */
    get request(): RequestEmitter<T, I, O>;
    /**
     * Helper for sending stream events.
     */
    get stream(): StreamEmitter<T, I, O>;
    /**
     * Helper for sending and handling subscriptions.
     */
    get subscriptions(): SubscriptionEmitter<T, I, O>;
    /**
     * Requests the server to send us new values for the given event and filter.
     *
     * @param event
     * @param filter
     * @param handler
     */
    subscribe<E extends SubscriptionEvents<O>>(event: E, filter: Filter<O, E>, handler: (receipt: Receipt, value: Value<O, E>) => void): Promise<Receipt>;
    /**
     * Closes all subscriptions on the server matching the given event and filter.
     *
     * @param event
     * @param filter
     */
    unsubscribe<E extends SubscriptionEvents<O>>(event: E, filter: Filter<O, E>): void;
    /**
     * Returns the socket instance for this client if it is active.
     */
    getSocket(): SocketIOClient.Socket | undefined;
    on(event: 'ready', listener: () => void): this;
    on(event: 'connect', listener: () => void): this;
    on(event: 'disconnect', listener: (reason: string) => void): this;
    on(event: 'reconnect', listener: (attempt: number) => void): this;
    on(event: 'reconnect_attempt', listener: (attempt: number) => void): this;
    on(event: 'reconnecting', listener: (attempt: number) => void): this;
    on(event: 'reconnect_error', listener: (error: Error) => void): this;
    on(event: 'error', listener: (error: Error) => void): this;
    on(event: 'reconnect_failed', listener: () => void): this;
    on(event: 'ping', listener: () => void): this;
    on(event: 'pong', listener: (latency: number) => void): this;
    on<E extends TransactionEvents<I>>(event: E, listener: Callback<I, E>): this;
    on(event: string, listener: (...args: any[]) => void): this;
    once(event: 'ready', listener: () => void): this;
    once(event: 'connect', listener: () => void): this;
    once(event: 'disconnect', listener: (reason: string) => void): this;
    once(event: 'reconnect', listener: (attempt: number) => void): this;
    once(event: 'reconnect_attempt', listener: (attempt: number) => void): this;
    once(event: 'reconnecting', listener: (attempt: number) => void): this;
    once(event: 'reconnect_error', listener: (error: Error) => void): this;
    once(event: 'error', listener: (error: Error) => void): this;
    once(event: 'reconnect_failed', listener: () => void): this;
    once(event: 'ping', listener: () => void): this;
    once(event: 'pong', listener: (latency: number) => void): this;
    once<E extends TransactionEvents<I>>(event: E, listener: Callback<I, E>): this;
    once(event: string, listener: (...args: any[]) => void): this;
    emit<E extends TransactionEvents<O>>(event: E, ...args: Params<O, E>): boolean;
    emit(event: string, ...args: any[]): boolean;
}
export interface ClientOptions<T extends Schematic> {
    /**
     * The host or IP address to connect to.
     */
    host: string;
    /**
     * The port to connect to.
     */
    port: number;
    /**
     * Optional authentication function. This can be overridden by passing a new authentication function into
     * `client.start()`.
     */
    auth?: (auth: Auth<T>) => void;
    /**
     * Custom options for the underlying socket.io client.
     */
    socket?: SocketIOClient.ConnectOpts;
    /**
     * Configures SSL encryption.
     */
    ssl?: ClientSSLOptions | boolean;
}
export interface ClientSSLOptions {
    /**
     * The contents of the client's private key in PEM format. The client does not need to provide a key to connect
     * to a server with SSL, unless the server requires the client to authenticate.
     */
    key?: Buffer | string;
    /**
     * The contents of the client's public key in PEM format. The client does not need to provide a key to connect
     * to a server with SSL, unless the server requires the client to authenticate.
     */
    cert?: Buffer | string;
    /**
     * If `true`, the client will reject the server if its certificate fails to validate according to our `ca`.
     * Defaults to `true`. It is highly recommended that you **do not** disable this option. If you disable this, the
     * connection will still be encrypted, but it will be vulnerable to man-in-the-middle attacks.
     *
     * @see `ca`
     */
    rejectUnauthorized?: boolean;
    /**
     * The CA certificate(s) to trust. If not specified, this defaults to Mozilla's bundle. This is used to check the
     * validity of the server's certificate. Generally, you should only use this option to whitelist self-signed
     * certificates, as the default should cover any reputable CAs.
     *
     * @see `rejectUnauthorized`
     */
    ca?: Buffer | string;
}
