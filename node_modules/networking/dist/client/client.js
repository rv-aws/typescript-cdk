"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const auth_1 = require("./auth");
const events_1 = require("events");
const requests_1 = require("../common/events/requests");
const streams_1 = require("../common/events/streams");
const transactions_1 = require("../common/events/transactions");
const dispatcher_1 = require("../common/events/dispatcher");
const streamer_1 = require("../common/stream/streamer");
const emitter_1 = require("../common/subscriptions/emitter");
const socket_io_client_1 = __importDefault(require("socket.io-client"));
const events = [
    'disconnect', 'reconnect', 'reconnect_attempt', 'reconnecting', 'reconnect_error', 'reconnect_failed',
    'ping', 'pong', 'error', 'ready', 'connect'
];
class Client extends events_1.EventEmitter {
    constructor(options, port) {
        super();
        if (typeof options === 'string') {
            if (typeof port !== 'number') {
                throw new Error('Port must be a number');
            }
            this.options = { host: options, port };
        }
        else {
            this.options = options;
        }
        this.emitters = {
            transactions: new transactions_1.TransactionEmitter(this),
            requests: new requests_1.RequestEmitter(this),
            streams: new streams_1.StreamEmitter(this),
            subscriptions: new emitter_1.SubscriptionEmitter(this)
        };
    }
    /**
     * Starts the client. If the `auth` parameter is provided, it will be called as an authentication helper and
     * provided an `Auth` instance as the sole parameter. The `auth` callback should generally return a Promise that
     * resolves when all authentication steps are complete.
     *
     * @param auth
     */
    start(auth) {
        return new Promise((resolve, reject) => {
            // Build the socket URL
            let s = !!this.options.ssl ? 's' : '';
            let url = `http${s}://${this.options.host}:${this.options.port}/`;
            // Build SSL options
            let options = this.options.ssl === true ? { secure: true } : (this.options.ssl ? {
                secure: true,
                key: this.prepareKey(this.options.ssl.key),
                cert: this.prepareKey(this.options.ssl.cert),
                ca: this.prepareKey(this.options.ssl.ca),
                rejectUnauthorized: this.options.ssl.rejectUnauthorized
            } : {});
            // Create the socket
            this.socket = socket_io_client_1.default(url, Object.assign(this.options.socket || {}, Object.assign(Object.assign({ path: '/', transports: ['websocket'] }, options), { transportOptions: {
                    websocket: {
                        hi: true
                    }
                } })));
            // Create the dispatcher and streamer
            this.dispatcher = new dispatcher_1.Dispatcher(this, this.socket, this.emitters);
            this.streamer = new streamer_1.Streamer(this, this.socket);
            // Forward events
            this.socket.on('error', (error) => this.emit('error', error));
            this.socket.on('disconnect', (reason) => this.emit('disconnect', reason));
            this.socket.on('reconnect', (attempt) => this.emit('reconnect', attempt));
            this.socket.on('reconnect_attempt', (attempt) => this.emit('reconnect_attempt', attempt));
            this.socket.on('reconnecting', (attempt) => this.emit('reconnecting', attempt));
            this.socket.on('reconnect_error', (error) => this.emit('reconnect_error', error));
            this.socket.on('reconnect_failed', () => this.emit('reconnect_failed'));
            this.socket.on('ping', () => this.emit('ping'));
            this.socket.on('pong', (latency) => this.emit('pong', latency));
            // Listen for connect errors
            this.socket.once('connect_error', (error) => {
                this.socket.off('connect');
                this.socket.off('connect_timeout');
                this.socket.close();
                this.socket = undefined;
                reject(error);
            });
            // Wait for the initial connection
            this.socket.once('connect', () => {
                this.emit('connect');
                this.emit('ready');
                this.socket.off('connect_error');
                this.socket.off('connect_timeout');
                let authenticator = auth || this.options.auth;
                if (authenticator) {
                    let response = authenticator(new auth_1.Auth(this.socket));
                    if (Promise.resolve(response) === response) {
                        response.then(() => {
                            this.socket.emit('@net/auth/term');
                            resolve();
                        }, error => {
                            this.socket.close();
                            this.socket = undefined;
                            reject(error);
                        });
                    }
                    else {
                        this.socket.emit('@net/auth/term');
                        resolve();
                    }
                }
                else {
                    this.socket.emit('@net/auth/term');
                    resolve();
                }
            });
        });
    }
    /**
     * Utility function for converting a key to a string.
     *
     * @param key
     * @internal
     */
    prepareKey(key) {
        if (Buffer.isBuffer(key)) {
            return key.toString();
        }
        return key;
    }
    /**
     * Helper for sending transaction events.
     */
    get transaction() {
        return this.emitters.transactions;
    }
    /**
     * Helper for sending request events.
     */
    get request() {
        return this.emitters.requests;
    }
    /**
     * Helper for sending stream events.
     */
    get stream() {
        return this.emitters.streams;
    }
    ;
    /**
     * Helper for sending and handling subscriptions.
     */
    get subscriptions() {
        return this.emitters.subscriptions;
    }
    // public subscribe(event: string, filter: Json, handler: (receipt: Receipt, value: any) => void) : Promise<Receipt>;
    subscribe(event, filter, handler) {
        return this.subscriptions.create(event, filter, handler);
    }
    // public unsubscribe(event: string, filter: Json) : void;
    unsubscribe(event, filter) {
        return this.subscriptions.remove(event, filter);
    }
    /**
     * Returns the socket instance for this client if it is active.
     */
    getSocket() {
        return this.socket;
    }
    /**
     * Returns the `Streamer` instance for this client.
     * @internal
     */
    getStreamer() {
        return this.streamer;
    }
    on(event, listener) {
        if (events.indexOf(event) >= 0)
            return super.on(event, listener);
        this.transaction.on(event, listener);
        return this;
    }
    once(event, listener) {
        if (events.indexOf(event) >= 0)
            return super.once(event, listener);
        this.transaction.once(event, listener);
        return this;
    }
    emit(event, ...args) {
        if (events.indexOf(event) >= 0)
            return super.emit(event, ...args);
        this.transaction.emit(event, ...args);
        return true;
    }
}
exports.Client = Client;
;
