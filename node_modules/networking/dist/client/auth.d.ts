/// <reference types="socket.io-client" />
import { Json } from '../common/serialize';
import { Schematic, Pull } from '../common/schema/schematic';
export declare class Auth<T extends Schematic> {
    private socket;
    /**
     * Constructs a new `Auth` instance.
     *
     * @param options
     */
    constructor(socket: SocketIOClient.Socket);
    /**
     * Sends the given credentials to the server and waits for a response. Returns `true` if the server accepts the
     * credentials, or throws an `AuthError` otherwise.
     *
     * @param credentials
     */
    login(credentials: Credentials<T>): Promise<true>;
    /**
     * Performs an encryption test against the server. In short, the server must also provide the same secret for
     * authentication to be successful, meaning both sides must know the secret key beforehand. This is rarely an
     * appropriate option for authentication, but when it is, it's a powerful way to prove the identities of both the
     * client and server. Throws an `AuthError` if the server fails the test.
     *
     * @param key
     */
    encrypt(secret: Secret<T>): Promise<true>;
}
export declare type Credentials<T extends Schematic> = Pull<T['authentication'], 'login', Json>;
export declare type Secret<T extends Schematic> = Pull<T['authentication'], 'encrypt', boolean>;
