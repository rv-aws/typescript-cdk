/// <reference types="node" />
import { Socket } from 'socket.io';
import { Server } from './server';
import { EventEmitter } from 'events';
import { TransactionEmitter, Callback, Params, Events as TransactionEvents } from '../common/events/transactions';
import { StreamEmitter } from '../common/events/streams';
import { RequestEmitter } from '../common/events/requests';
import { Auth } from './auth';
import { SubscriptionEmitter } from '../common/subscriptions/emitter';
import { Schematic, Fallback, Group } from '../common/schema/schematic';
export declare class Connection<T extends Schematic = Schematic, I = Fallback<T['server'], Group>, O = Fallback<T['client'], Group>> extends EventEmitter {
    private server;
    private socket;
    constructor(server: Server, socket: Socket);
    auth(callback: (auth: Auth<T>) => Promise<void>): Promise<void>;
    /**
     * Helper for sending transaction events.
     */
    get transaction(): TransactionEmitter<T, I, O>;
    /**
     * Helper for sending request events.
     */
    get request(): RequestEmitter<T, I, O>;
    /**
     * Helper for sending stream events.
     */
    get stream(): StreamEmitter<T, I, O>;
    /**
     * Helper for sending and handling subscriptions.
     */
    get subscriptions(): SubscriptionEmitter<T, I, O>;
    /**
     * Returns the socket instance for this client if it is active.
     */
    getSocket(): Socket;
    /**
     * Returns `true` if this connection had an authentication method.
     */
    get authenticated(): boolean;
    on(event: 'disconnect', listener: (reason: string) => void): this;
    on(event: 'disconnecting', listener: (reason: string) => void): this;
    on(event: 'error', listener: (error: Error) => void): this;
    on(event: string, listener: (...args: any[]) => void): this;
    on<E extends TransactionEvents<I>>(event: E, listener: Callback<I, E>): this;
    once(event: 'disconnect', listener: (reason: string) => void): this;
    once(event: 'disconnecting', listener: (reason: string) => void): this;
    once(event: 'error', listener: (error: Error) => void): this;
    once<E extends TransactionEvents<I>>(event: E, listener: Callback<I, E>): this;
    once(event: string, listener: (...args: any[]) => void): this;
    emit<E extends TransactionEvents<O>>(event: E, ...args: Params<O, E>): boolean;
    emit(event: string, ...args: any[]): boolean;
}
