import { Socket } from 'socket.io';
import { Schematic, Pull } from '../common/schema/schematic';
export declare class Auth<T extends Schematic> {
    private socket;
    constructor(socket: Socket);
    /**
     * Waits for the client to send login credentials and returns them. To accept the credentials, use the `accept`
     * method. To reject them, use the `reject` method. Throws an `AuthError` if the client fails does not send any
     * login credentials.
     */
    login(): Promise<Credentials<T>>;
    /**
     * Performs an encryption test against the client. In short, the client must also provide the same secret for
     * authentication to be successful, meaning both sides must know the secret key beforehand. This is rarely an
     * appropriate option for authentication, but when it is, it's a powerful way to prove the identities of both the
     * client and server. Throws an `AuthError` if the server fails the test.
     *
     * @param key
     */
    encrypt(secret: Secret<T>): Promise<true>;
    /**
     * Sends an acceptance or rejection packet to the client.
     */
    success(success: boolean): void;
    /**
     * Sends an acceptance packet to the client.
     */
    accept(): void;
    /**
     * Sends a rejection packet to the client.
     */
    reject(): void;
}
export declare type Credentials<T extends Schematic> = Pull<T['authentication'], 'login', any>;
export declare type Secret<T extends Schematic> = Pull<T['authentication'], 'encrypt', boolean>;
