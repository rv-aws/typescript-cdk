"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const transactions_1 = require("../common/events/transactions");
const streams_1 = require("../common/events/streams");
const requests_1 = require("../common/events/requests");
const dispatcher_1 = require("../common/events/dispatcher");
const auth_1 = require("./auth");
const streamer_1 = require("../common/stream/streamer");
const emitter_1 = require("../common/subscriptions/emitter");
const events = [
    'disconnect', 'disconnecting', 'error'
];
class Connection extends events_1.EventEmitter {
    constructor(server, socket) {
        super();
        this.server = server;
        this.socket = socket;
        /**
         * @internal
         */
        this.hadAuthentication = false;
        // Create emitters
        this.emitters = {
            transactions: new transactions_1.TransactionEmitter(this),
            requests: new requests_1.RequestEmitter(this),
            streams: new streams_1.StreamEmitter(this),
            subscriptions: new emitter_1.SubscriptionEmitter(this)
        };
        // Forward events
        socket.on('error', (error) => this.emit('error', error));
        socket.on('disconnect', (reason) => this.emit('disconnect', reason));
        socket.on('disconnecting', (reason) => this.emit('disconnect', reason));
        // Create the dispatcher
        this.dispatcher = new dispatcher_1.Dispatcher(this, socket, this.emitters);
        this.streamer = new streamer_1.Streamer(this, socket);
    }
    auth(callback) {
        return new Promise((resolve, reject) => {
            let auth = new auth_1.Auth(this.socket);
            let response = callback(auth);
            if (Promise.resolve(response) !== response) {
                return reject(new Error('Auth method must return a promise'));
            }
            this.hadAuthentication = true;
            response.then(() => {
                this.socket.emit('@net/auth/term');
                auth.queue.getTermination().then(resolve);
            }, err => {
                this.socket.disconnect(true);
                reject(err);
            });
        });
    }
    /**
     * Helper for sending transaction events.
     */
    get transaction() {
        return this.emitters.transactions;
    }
    /**
     * Helper for sending request events.
     */
    get request() {
        return this.emitters.requests;
    }
    /**
     * Helper for sending stream events.
     */
    get stream() {
        return this.emitters.streams;
    }
    ;
    /**
     * Helper for sending and handling subscriptions.
     */
    get subscriptions() {
        return this.emitters.subscriptions;
    }
    /**
     * Returns the socket instance for this client if it is active.
     */
    getSocket() {
        return this.socket;
    }
    /**
     * Returns `true` if this connection had an authentication method.
     */
    get authenticated() {
        return this.hadAuthentication;
    }
    /**
     * Returns the `Streamer` instance for this connection.
     * @internal
     */
    getStreamer() {
        return this.streamer;
    }
    on(event, listener) {
        if (events.indexOf(event) >= 0)
            return super.on(event, listener);
        this.transaction.on(event, listener);
        return this;
    }
    once(event, listener) {
        if (events.indexOf(event) >= 0)
            return super.once(event, listener);
        this.transaction.once(event, listener);
        return this;
    }
    emit(event, ...args) {
        if (events.indexOf(event) >= 0)
            return super.emit(event, ...args);
        this.transaction.emit(event, ...args);
        return true;
    }
}
exports.Connection = Connection;
