"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const connection_1 = require("./connection");
const socket_io_1 = __importDefault(require("socket.io"));
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
class Server extends events_1.EventEmitter {
    constructor(options) {
        super();
        if (typeof options === 'number')
            this.options = { port: options };
        else
            this.options = options;
    }
    /**
     * Starts the client. If the `auth` parameter is provided, it will be called as an authentication helper and
     * provided an `Auth` instance as the sole parameter. The `auth` callback should generally return a Promise that
     * resolves when all authentication steps are complete.
     *
     * @param auth
     */
    start() {
        let server;
        // Create an HTTP server if SSL is not enabled
        if (!this.options.ssl) {
            server = http_1.default.createServer();
        }
        // Otherwise, create an HTTPS server with the SSL configuration
        else {
            server = https_1.default.createServer({
                key: this.options.ssl.key,
                cert: this.options.ssl.cert,
                ca: this.options.ssl.ca,
                rejectUnauthorized: this.options.ssl.rejectUnauthorized,
                requestCert: this.options.ssl.requestCert
            });
        }
        // Start the server on the configured port
        server.listen(this.options.port);
        // Attach socket.io to the server
        this.server = socket_io_1.default.listen(server, Object.assign(this.options.server || {}, { path: '/' }));
        // Wait for connections
        this.server.on('connection', socket => {
            let connection = new connection_1.Connection(this, socket);
            let listeners = this.listeners('connection');
            for (let listener of listeners) {
                let response = listener.call(connection, connection);
                if (Promise.resolve(response) === response) {
                    response.then(() => {
                        if (!connection.authenticated) {
                            socket.emit('@net/auth/term');
                        }
                    });
                }
                else {
                    if (!connection.authenticated) {
                        socket.emit('@net/auth/term');
                    }
                }
            }
        });
    }
    /**
     * Listens for an event.
     *
     * @param event
     * @param listener
     */
    on(event, listener) {
        return super.on(event, listener);
    }
}
exports.Server = Server;
;
